大家好，我是修言。欢迎大家和我一起走进函数式编程的世界ღ( ´･ᴗ･` )。

  


即使是在瞬息万变的前端领域，也存在一些具备“一次学习，终生受用”特性的知识—— 这是我每本小册的固定开篇语，也是我内心深处用来甄别“好知识/快餐知识”的“金标准”。

  


“好知识”经得起时间的考验、经得起软件技术快速更迭带来的重重挑战。

“好知识”不仅值得开发者在生产活动中持续实践，更值得技术作者对其进行反复的钻研、拆解和体系化。

  


具体到这本小册上来说，毫无疑问，函数式编程就是修言价值体系里的“好知识”。

## 函数式编程：是“优美范式”，更是“进阶套路”

### 函数式编程是一种编程范式。

编程范式可以理解为编程的风格/方式，它决定了我们将以一种什么样的方法和规范去组织自己的代码，是一门研究“如何写代码”的学问。

对前端工程师来说，我们可能接触过的编程范式有以下几种：

-   命令式编程
-   面向对象编程
-   函数式编程

我们之所以“有可能”接触过这 3 种范式，是因为 **JS 是多范式的语言**。

### JS 是多范式的语言

有一些语言是典型的命令式语言，比如 C 语言、BASIC 语言。

有一些语言是典型的面向对象语言，比如 Java、C++。

有一些语言则是典型的函数式语言，比如 Haskell、Clojure。

而 **JS 则是多范式的编程语言**，它同时包罗了这 3 种编程范式。

出于一些历史原因，在实际的工作中，不少前端同学可能会更倾向于写命令式/面向对象的代码。

在我整个工作生涯接手过的存量代码中，命令式/面向对象代码在比例上也占据了绝对的上峰。

但最近几年，这个形势发生了一些微妙的变化。

### 前端工程师，站在函数式编程的肩膀上

我们可以看到的是，**越来越多的前端工程师开始使用函数式编程**。

这其中不仅仅包括早期那批由数学理论切入函数式编程的初代发烧友，更包括了一大票从未系统学习过函数式编程的开发者——比如热门框架 React 的用户：不管一个前端程序员懂不懂函数式编程，只要他基于 React 的生态去构建应用程序，那就很难不用到函数式编程。

这是因为 React 框架已经从语法/最佳实践等层面约束了用户的代码风格，确保不管什么背景的开发者，都能写出函数式的代码、构建出声明式的数据流。

也就是说，在你自己完全不知情的情况下，你可能早已站在了函数式编程的肩膀上。

**这背后的趋势，是前端世界，乃至整个软件行业，都在越来越全面、越来越深入地拥抱函数式编程。**

## 函数式浪潮中的前端生态

为什么 React 选择逐步告别 Class 组件，拥抱“函数组件”？

为什么 Redux 的 Reducer 必须是“纯函数”？

为什么各路前端框架、小程序框架总在强调“不可变值”？

为什么各厂的前端面试中，无论是问答题目还是 coding-test，都开始越来越频繁地考察高阶函数、柯里化、偏函数、compose/pipe 等函数式能力？

归根结底，是因为**函数式思想正在以越来越快的速度渗透前端生态**。

在遥远的过去，函数式编程对于切图仔来说，或许还只是一门“有点意思”的选修课。

但在2022年的今天，在前端应用复杂度呈指数级增长的现在，函数式编程无疑已经成为前端工程师进阶的必修课。

不管你有没有冲过函数式，轮子们已经先冲了，这些轮子包括但不限于：

-   React
-   Redux
-   Ramda.js
-   Lodash/fp
-   Immutable.js
-   Immer.js
-   Rx.js（ReactiveX）
-   Webpack

......

在这些现代前端框架/库中，有的借助函数式思想实现了部分功能，有的则整个基于函数式来设计自身的软件架构。

我们将会在后续的小节中对这些框架/库做更进一步的分析，从原理和设计模式的层面理解它们是如何应用/实现/支持函数式的。

  


## 函数式编程的学习之道  

>真正的知识是本质的，它是从基础开始构建的。举一个数学例子，不先理解算术和几何是无法理解三角学的。   
基本上，如果有人使用很多复杂的词汇和很多大概念，他们很有可能不知道他们自己在谈论什么。   
我认为最聪明的人能把事情向小孩子讲明白。如果你无法向小孩子讲明白，那么你并不是真的知道。                                                       ——纳瓦尔


### 编程“套路”学：从设计模式到函数式编程

既然函数式编程是“写代码”的学问，那么它和我们之前学过的[设计模式](https://juejin.cn/book/6844733790204461070)一样，都属于是编程的“套路”。

事实上，两者之间也确实有许多互通的地方：
- 它们都致力于**解决软件设计的复杂度的问题**
- 它们的着力点都在于“**如何应对变化**”
- 它们都引导我们**用健壮的代码解决具体的问题**、**用抽象的思维应对复杂的系统** ......

然而，同为“套路”，函数式编程的学习曲线却比设计模式陡峭得多，在面试场景下也具备更高的区分度。

但也正因为都是“套路”，我们曾经用来对付设计模式的那些学习方法，在函数式编程这里仍不过时。

在内容表达上，我们仍然会借助大量的图解+编码案例+现实生活中的体验类比，从具体的实践/感知去推导抽象的原理。

在知识结构上，我们仍然会将大的知识体系拆解为“道”与“术”两个分支，知其然，更知其所以然。

我们整本小册的知识体系与格局，用思维导图展示如下：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00adb0db3c4348ca975b4fa15ccab73e~tplv-k3u1fbpfcp-watermark.image?)
### 从范式特征来认识函数式编程

在小册的开篇，我们首先会从范式的**特征**来认识函数式编程，解决“函数式编程是什么”的问题。

与“特征”相对的，是“定义”。我们先来看行业内较为主流的一种函数式编程定义：

> 函数式编程是一种强调以函数使用为主的软件开发风格。       ——[美]路易斯·阿泰西奥
  


这个版本的定义很简短，这句话似乎也没有什么理解壁垒。   
遗憾的是，即便是读上100遍，我们也很难 get 到我们想要的有效信息。因为这个定义，实在是太简洁了，或者说，**太抽象了！**

那么有没有信息量稍大一些的定义呢？  
此时如果你转战以”全面、详尽“而著称的 Wikipedia，那么你大概率会得到一个更加令人费解的定义：

> 函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式。  
它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。      
其中，λ演算为该语言最重要的基础。而且，λ演算的函数可以接受函数作为输入参数和输出返回值。                                                          ——Wikipedia

  


这条定义倒是信息量很大，但是数学浓度太高，我们土狗前端实在很难消化。

这咋整呢？   
其实，对于编程范式来说，我们可以认为“**特征即定义”** 。 就 JS 函数式编程而言，以下三个特征可以说是没跑了：

-   拥抱纯函数，隔离副作用
-   函数是“一等公民”
-   避免对状态的改变（不可变值）

这三个特征，将会是我们探讨函数式编程之“道”的重要线索，也是我们后续实践函数式编程之“术”的基本依据。

## 其实不难

不可否认，函数式编程是“软件设计核心知识”中科普率较低的一块知识：晦涩的数学概念、弯弯绕绕的“新名词”，碎片化的学习材料，这些无一不在蚕食着大家进阶道路上的耐心和信心。

其中，“晦涩的数学概念”可能是所有劝退因素中最首当其冲的一个。

在本册中，我希望能够站在实践的角度，引导大家重新去看待数学与代码之间的关系。

**数学之于函数式编程，正如化学之于厨师。** 

厨师做菜，表面上靠厨艺，原理上靠科技。

这个“科技”不是说他往菜里加了多少添加剂，而是说烹饪这个过程，本身就伴随了许多的化学反应。

比如烤肉那股香味，就来自高温加热蛋白质和碳水触发的美拉德反应；而米饭从生到熟的过程中，会发生糊化反应等等。

成为一个高级厨师，可能需要一些必要的化学常识作为背景，但未必需要精通化学反应原理。

我们程序员写代码，也是如此。

本着“以己之长学人之长”的原则，我 们在学习面向编程的数学时 ，其实不必太拘泥于“由数学去推导数学”这个过程，而应该试着**用代码去推导数学**。  

**厨师在做菜的过程中，自然会通过现象去理解食物分子的变化。**

**而我们在编码的过程中，自然也能够通过代码的行为来理解数学的奥义。**

这一点，随着学习的深入，相信大家会有越来越强烈的共鸣。

  